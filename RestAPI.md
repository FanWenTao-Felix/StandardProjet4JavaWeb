### 如何减少接口响应时间

本文选自《开发者头条》3 月 13 日用户分享，感谢作者 佐井 分享。
欢迎分享：http://toutiao.io/contribute

Premature optimization is the root of all evil.
— Donald Knuth

对于程序优化，我一直采取保守的态度，除非万不得已。但是随着业务的不断发展，程序越来越复杂，代码越写越多，优化似乎是终有一天会到来的事情。

那么对于一个典型的后台服务接口，我们可以从那些方面入手进行优化呢？

接口拆分
接口垂直拆分
垂直拆分可以简单理解为微服务化，把一个大而复杂的服务拆分成多个相互独立，职能单一的服务，单独部署。 更细粒度拆分的好处是，能对某个具体的微服务进行特殊优化，以最大的投入产出比来解决整个服务的性能。 垂直拆分还有一个好处是，对于非必须的接口，可以很方便的进行降级处理，把坏影响隔离到核心逻辑外部。 最容易想到的优化办法是把某个对整体性能有决定性影响的微服务接口进行水平扩容。

注意: 拆分后必定会增加外部接口调用，多少会有些额外开销，但是对于有限几个调用，拆分的还是值得的。

接口水平拆分
这里说的水平拆分一定不是把一个接口部署更多份，因为这样只能解决接口的容量问题，但是不能减少接口的响应时间。 水平拆分可以简单理解成mapreduce模型，把整个计算逻辑或者数据平均分配到集群中的N个服务器去，然后由一台机器去并发调用并做结果合并。 理论上这种方式能把响应减少到1/N+合并+调用开销的时间。

注意： 一个问题需要考虑的是，如果并发调用的接口返回的数据量比较大，可能会对合并机器的网络负载和数据序列化(CPU)有一定影响。

缓存
接口缓存
一个有着复杂逻辑或者大量计算数据的接口，能对整个结果进行缓存再好不过了。缓存针对不同的场景会有多种策略，对于有大量并发请求的场景， 推荐一个方案：一种基于“哨兵”的分布式缓存设计，不会有损失第一个用户，也不会有定时更新缓存的额外开销。

本地缓存
本地缓存有两种场景，对于类似字典类型的数据，可以静态化后放入内存，定时去刷新或者采用通知机制去更新。

还有一种场景是用ThreadLocal缓存重复内部计算与重复的对象创建； 对于链路比较长或者循环比较深的接口，ThreadLocal减少重复计算和对象创建，从而降低RT和节约内存。

注意： 在有内部并发的地方使用ThreadLocal一定要注意不同线程间的数据同步。主线程的ThreadLocal数据和每个并发子线程的ThreadLocal数据要同步好。

内部优化
非核心流程异步化
类似于发消息，写日志，更新缓存等不会影响接口准确性的非核心流程，可以采用异步方式进行处理，不阻塞主计算逻辑处理。

内部并发
如果进行水平拆分后，并发调用IO较大，可以考虑换成内部并发解决IO问题。如果内部并发涉及到每个线程更新同一个集合数据，不用忘了使用线程安全的集合。 这里有一个并发更新HashMap的case：并发环境下HashMap引起full gc排查。

总结
优化一定不是一蹴而就的，整个优化过程是一个统计-->方案-->验证的闭环，需要不断试错，不断挖掘，最终达到预期。

---

### 浅谈 API 安全设计

本文选自《开发者头条》3 月 21 日用户分享，作者 @IM_Jun ，感谢 Maxiee 分享。
欢迎分享：http://toutiao.io/contribute

一、简述
安全是恒久的话题，如果不注意防范，会带来很严重的后果。比如：
1.接口被大规模调用消耗系统资源，影响系统的正常访问，甚至系统瘫痪
2.数据泄露
3.伪造（篡改）数据，制造垃圾数据
4.App被仿制…

那么我们设计API时，就要保证RESTful API的安全性，主要包括三大方面：
a) 对受限资源的登录授权
b) 对请求做身份认证，并且防止篡改，重放攻击
c) 对敏感的数据做加密

二、受限资源的登录授权
此流程不是本文重点，不赘述，基本流程如下：
1. 客户端提交账号信息（用户名+密码）到服务端
2.  服务端验证成功，返回AccessToken给客户端存储
3.访问受限资源时，客户端带入AccessToken就可访问。

三、请求认证
如果不对请求进行签名认证，那么可以简单的通过fiddler等工具轻易抓包拿到数据，并进行篡改，提交，大规模批量调用，则会使系统产生大量垃圾数据，系统资源被大量消耗，甚至无法正常使用（另说，当然可以通过GateWay进行限流），因而我们需要对请求进行签名认证。

URL格式
URL:schema://domain/path?query&imei×tamp&sign


参数说明
签名方法
sign=signature(path?query&imei×tamp&SIGN_KEY)


验证过程
认证逻辑
1、初始时，服务端存有各App版本的SIGN_KEY，客户端存有对应版本的SIGN_KEY
2、当要发送请求之前，通过签名方法加密，得到一个sign
3、发送请求的时候，连同sign一起发送给服务器端
4、服务器端首先验证时间戳timestamp是否有效，比如是服务器时间戳5分钟之前的请求视为无效；
5、然后取对应版本的SIGN_KEY验证sign是否合法
6、为了防止重放攻击，需要检查sign是否在redis中存储，如不存在则存入redis（缓存5分钟）

如何防止数据篡改
这里通过签名参数中包含原有请求的所有参数，改动任意参数，sign值都会不同，因此无法篡改。

如何防止重放攻击
由于签名算法中还有imei(设备唯一Id)、timestamp参数，且签名算法为不可逆算法（如md5或sha1），因而对于正常的每个请求sign值不会重复。此时服务端可以存储5分钟的sign值，来做重放攻击时的验证过滤，超过5分钟的请求则直接被timestamp校验过滤。

总结
如此便实现了请求认证，防止数据篡改，重放攻击，但是需要确保App密钥(SIGN_KEY)的安全保存，其优点是容易理解与实现，缺点是需要承担安全保存密钥和定期更新密钥的负担。

四、敏感据加密
1)、部署SSL基础设施（即HTTPS），敏感数据的传输全部基于SSL。
2)、仅对部分敏感数据做加密（例如账号+密码），并加入某种随机数作为加密盐，以防范数据被篡改。

----
最好的8个 Java RESTful 框架
<http://colobu.com/2015/11/15/best-available-java-restful-micro-frameworks/>
Dropwizard
Jersey
Ninja Web Framework
Play Framework
RestExpress
Restlet
Restx
Spark Framework

---
RESTful API 学习资料
<https://github.com/aisuhua/restful-api-design-references>